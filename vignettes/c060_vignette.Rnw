% setwd("C:/Projekte/explained variation/peperr/CSDA/c060/vignettes")
% setwd("~/Projekte_StatsMethods/c060_workcopy/vignette")
% library(cacheSweave)
% Sweave("c060_vignette.Rnw", driver = cacheSweaveDriver)
% tools::texi2dvi("c060_vignette.tex", pdf=TRUE)

\documentclass[preprint, 11pt, authoryear]{elsarticle}

\usepackage{graphicx}
\usepackage{mathptmx}      % use Times fonts if available on your TeX system
\usepackage[authoryear]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{color}
\usepackage{pst-all}

% please place your own definitions here and don't use \def but
% \newcommand{}{}
\newcommand{\Scmd}[1]{\texttt{#1}} % For R/ S commands
\newcommand{\R}{R}

\definecolor{red}{rgb}{1,0.4,0.4}
\definecolor{blue}{rgb}{0.4,0.4,1}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{gradbegin}{rgb}{0.6,0.1,0.6} % purple
\newcommand{\commentMZ}[1]{\textit{\textbf{\red[Manuela: #1]}}}

\journal{Computational Statistics \& Data Analysis}

\begin{document}
\SweaveOpts{concordance=TRUE}
%\SweaveOpts{concordance=TRUE}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\setkeys{Gin}{width=\linewidth}% general figure width
\SweaveOpts{prefix.string=figures/fig, eps=FALSE}
%Because eps=FALSE, all graphics are created as pdf graphics only. This implies that the resulting tex document needs to be compiled with pdflatex rather than with latex.

\title{Extended inference with lasso and elastic-net regularized Cox and generalized linear models}
\author{Martin Sill\corref{cor1}}
\author{Thomas Hielscher, Natalia Becker, Manuela Zucknick}
\address{Division of Biostatistics, German Cancer Research Center, Im Neuenheimer Feld 280, 69120 Heidelberg, Germany}

\cortext[cor1]{Corresponding author: m.sill@dkfz-heidelberg.de}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\begin{abstract}
We have developed the \R{} package \texttt{c060} with the aim of improving \R{} software functionality for high-dimensional risk prediction modelling, e.g. for prognostic modelling of survival data using high-throughput genomic data. 

Penalized regression models provide a statistically appealing way of building risk prediction models from high-dimensional data. The popular CRAN package \texttt{glmnet} package implements an efficient algorithm for fitting penalized Cox and generalized linear models. However, in practical applications the data analysis will typically not stop at the point where the model has been fitted. One is for example often interested in the stability of selected features and in assessing the prediction performance of a model and we provide functions to deal with both of these tasks. Our \R{} functions are computationally efficient and offer the possibility of speeding up computing time through parallel computing. Another feature which can drastically reduce computing time is an efficient interval-search algorithm, which we have implemented for selecting the optimal parameter combination for elastic net penalties.

These functions have been useful in our daily work at the German Cancer Research 
Center where prognostic modelling of patient survival data is of particular interest. Although we focus on a survival data application of penalized Cox models in this article, the functions in our \R{} package are applicable to all types of regression models implemented in the \texttt{glmnet} package.

\end{abstract}

\begin{keyword}
penalized log-likelihood method, stability selection, interval search, prediction error, R software
\end{keyword}

\end{frontmatter}

\section{Introduction}
\label{intro}

Penalized regression models provide a statistically appealing method to build prediction models from high-dimensional data sources, where it is the aim to simultaneously select features and to fit the model \citep{fan2010,benner2010}. Since the introduction of the lasso for linear regression models \citep{tibshirani96}, the methodology has been extended to generalized linear regression models and time-to-event endpoints \citep{tibshirani97} among others. In addition to the well-known $L_1$- (lasso) and $L_2$-norm (ridge) penalty functions, various other penalties have been proposed in recent years to select features and/or estimate their effects. In particular, we will use the elastic net penalty function \citep{zou05}, which is a linear combination of the $L_1$- and $L_2$-norms.

With ever increasing data, the properties of the algorithm used for fitting the model have become almost as important as the statistical model itself. 
In 2010, Friedman et al. proposed a coordinate descent algorithm \citep{FHT2010} for generalized linear regression models, which has since then been extended to penalized Cox proportional hazards (PH) regression models \citep{simon2011}. Due to its efficiency this algorithm is considered one of the state-of-the-art
approaches to estimate penalized regression models with lasso, ridge or elastic net penalty terms, especially in high-dimensional data scenarios. 

This algorithm has been implemented in \R{} \citep{R11} in the \texttt{glmnet} package. The package provides functions to tune and fit regression models, 
plot the results, and make predictions. However, in practical applications, where often an independent validation data set is lacking, some additional features and routines are desirable as part of a complete data analysis. We have assembled some functions that enhance the existing functionality of the \texttt{glmnet} package or
allow to use it within the framework of other existing \R{} packages. These functions have been useful in our daily work at the German Cancer Research 
Center where prognostic modelling of patient survival data is of particular interest. Therefore, for illustration purposes we focus on penalized Cox PH regression models in this article. But the \R{} functions are applicable to all types of regression models implemented in the \texttt{glmnet} package.

Computational efficiency is an important requirement of the software to make applications feasible for real-life data analysis tasks in fields such as molecular oncology, where one aims to develop sparse risk prediction models based on very large numbers of molecular features measured with high-throughput technologies such as microarrays or next-generation sequencing. Therefore, we provide functionality to speed up computations, in particular through parallel computing.

We provide \R{} functions to perform stability selection \citep{MeinshausenBuehlmann2010} in a computationally efficient way using \texttt{glmnet} which allows to select the most stable features at a given error level. We have also implemented an approach to select the optimal parameter combination ($\alpha$, $\lambda$) for elastic net penalties using an interval-search algorithm \citep{froehlich2005} which is often faster and more accurate than a standard grid search \citep{Jones1998}. Another very useful addition for real-life applications of \texttt{glmnet} for building risk-prediction models is the provision of wrapper functions to allow the computation of resampling-based prediction errors within the framework of the \R{} package \texttt{peperr} \citep{Porz2009}. The \texttt{peperr} package makes it computationally feasible to assess the
predictive accuracy of a penalized regression model via resampling methods even for very large-scale applications by employing parallel computing. We also provide the possibility to speed up stability selection by parallel computing using the functionalities of the \R{} base package \texttt{parallel}.

The software is available as \R{} package \texttt{c060} on R-forge (URL \url{http://c060.r-forge.r-project.org}). 

\section{Data application}
Throughout this article we use the gene expression data set of cytogenetically normal acute myeloid leukemia (AML) patients by \citet{metzeler08} and corresponding clinical data in order to illustrate a typical application of penalized Cox PH regression models, where the aim is to develop a prognostic model for patient survival while at the same time identifying the most influential gene expression features. To simulate the typical situation that only one data set is available for model training and evaluation, we only use the data set that was used as validation data in the original publication by \citet{metzeler08}. The data can be accessed from the Gene Expression Omnibus (GEO) data repository (\url{http://www.ncbi.nlm.nih.gov/geo}) by the National Center for Biotechnology Information (NCBI). We find the Metzeler \textit{et al.} data set under GEO accession number GSE12417.

The data set contains gene expression data for 79 patient samples measured with Affymetrix HG-U133 Plus 2.0 microarrays. The median survival time of these 79 patients was 17.6 months with a censoring rate of 40\%.

\section{Methods and algorithms}

\subsection{Penalized generalized linear models and Cox models}\label{methods:penalized}
An efficient implementation for fitting generalized linear models and Cox proportional hazards models with regularization by the lasso or elastic net penalty terms is provided by the \R{} package \texttt{glmnet} \citep{FHT2010, simon2011}. This implementation uses a coordinate descent algorithm for fitting the models for a specified penalty parameter value $\lambda$. The computation of an entire regularization path across a range of values $\Lambda = \{\lambda_1,\lambda_2...,\lambda_K\}$ with \texttt{glmnet} is generally very fast, because previously computed solutions for $\{\lambda_1,...,\lambda_{k-1}\}$ are used as 'hot' starting values for the computation of $\lambda_k$. This implies that it is often more efficient to compute the models for the entire regularization path rather than just individual models. We use this feature of \texttt{glmnet} in all of our implemented algorithms to make most use of the computational speed of \texttt{glmnet}.

Models are fitted by maximizing the penalized log-likelihood function for generalized linear models and the penalized partial log-likelihood for Cox models. The penalized (partial) log-likelihood function is given by
\begin{equation}\label{pen.part.likelihood}
l_n(\boldsymbol\beta)- \sum_{j=1}^p  p_{\lambda}(|\beta_j|)
\end{equation}
where $l_n(\boldsymbol\beta)$ denotes the (partial) log-likelihood given $n$ observations.
The dimension of the parameter vector $\boldsymbol\beta$ is $p$ and $p_\lambda(|\cdot|)$ is the penalty function with tuning parameter $\lambda$.

Cross-validation can be performed to decide which model, i.e. which penalty parameter values, to choose by using the negative cross-validated penalized (partial) log-likelihood as the loss function. Actually, within the \texttt{glmnet} package, the penalized (partial) log-likelihood deviance is used as the loss function rather than the log-likelihood function itself. The deviance is equal to -2 times the log-likelihood ratio of the model of interest compared to the saturated model, which has one free parameter per observation. Obviously, both versions will result in the same optimization result.

\subsection{$L_2$-penalized Cox regression}
Penalized maximum likelihood estimation in Cox regression with the ridge penalty
\begin{equation}\label{ridge}
p_\lambda(|\beta_j|)=\lambda\beta_j^2
\end{equation}
was introduced by \citet{verweij94}.
The ridge penalty results in parameter estimates that are biased towards zero, but does not set values to exactly zero, and hence does not perform feature selection.
On the other hand, it has been found to produce models with good prediction performance in high-dimensional genomic applications \citep[e.g.][]{bovelstad07}, in particular if predictors are highly correlated.

\subsection{$L_1$-penalized Cox regression}
\Citet{tibshirani97} proposed to use an $L_1$-penalized Cox model with
\begin{equation}
p_\lambda(|\beta_j|)=\lambda | \beta_j |
\end{equation}
and described a technique, called the lasso for ``least absolute shrinkage and selection operator'', for parameter estimation.
The $L_1$-penalty has the advantage over the $L_2$-penalty of shrinking some of the coefficients to zero, i.e. it performs automatic feature selection.

\subsection{The elastic net}
\Citet{zou05} introduced the elastic net, which employs a combination of the $L_1$- and $L_2$-penalty
\begin{equation}\label{enet}
p_{\lambda_1,\lambda_2}(|\beta_j|)=\lambda_1 | \beta_j | + \lambda_2 \beta_j ^2.
\end{equation}
\Citet{zou05} rescale the initial solutions from the optimization of the doubly-penalized log-likelihood function by the factor $1 + \lambda_2$, in order to reduce the effect of the double shrinkage.
Like lasso the elastic net performs automatic feature selection by setting some coefficient estimates to zero.
But the additional $L_2$-penalty term distributes the weight to more features, such that the elastic net tends to select more features than the lasso. 
This is especially the case in situations with high correlation, where the lasso would select only one feature of a set of highly correlated features, while the ridge penalty would give them equal weight.

Throughout this manuscript we use an alternative parametrization of the elastic net penalty function equivalently to the formulation used in the \texttt{glmnet} package:
\begin{equation}\label{enet2}
p_{\alpha,\lambda}(|\beta_j|)= \lambda\times (\alpha |\beta_j| + (1-\alpha)\frac{1}{2} \beta_j^2).
\end{equation}
Here, $\alpha \in (0,1]$ determines the influence of the $L_1$ penalty relative to the $L_2$ penalty. Small $\alpha$ values will result in models with many features, getting closer to the non-sparse ridge solution as $\alpha$ tends to zero.

\subsubsection{The interval-search algorithm to select the optimal elastic net parameter combination}
The elastic net penalty function contrains two tuning parameters which are data-dependent and hence cannot be set to some \emph{a priori} values. The challenge is to find a set of tuning parameters $\left(\alpha,\lambda\right)$, for which the k-fold cross-validated loss function of the model is minimal.

\paragraph{Fixed grid}
Tuning parameters are usually determined by a grid search. The grid search method calculates a target value,
e.g. the penalized log likelihood deviance, at each point over a fixed grid of parameter values. This method may offer some
protection against local minima but it is not very efficient. 
The density of the grid plays a critical role in finding global optima. By increasing the density of the grid, the computation cost increases rapidly with no guarantee of finding global optima. 
Furthermore, the choice of the fixed grid is highly arbitrary and does not protect from getting stuck in local optima. 

\paragraph{Interval search}
\Citet{froehlich2005} proposed an 
efficient algorithm for finding a global optimum on the tuning parameter space 
called Efficient Parameter Selection via Global Optimization (EPSGO). The main idea of the algorithm is to treat the task of finding the optimal tuning parameter value as a global optimization problem. For that purpose one learns a Gaussian process model of the loss function surface in parameter space and samples systematically at points where the so-called expected improvement criterion reaches the maximum. 

The interval search can be divided into two phases. In the initial phase, a set of uniformly distributed points is randomly selected throughout the parameter space. Then, in the iteration phase, the algorithm learns the Gaussian process model from the points which have already been visited. By adding new points one updates the Gaussian process model.
New points in the parameter space are sampled by using the expected improvement criterion as described by \citet{Jones1998}, which avoids getting stuck in local minima. The EPSGO algorithm stops when the global optimum is achieved.

One can observe an immense improvement in the training time for the Gaussian process model compared to that of the underlying classification and regression tasks \citep{froehlich2005}. This is because the number of training points for the Gaussian process (and hence the number of evaluations of the loss function surface of the regression model) mainly depends on the dimensionality of the parameter space, which is very small compared to the number of training points for the regression model. 

\subsection{Stability selection}
The penalized regression models that we have described above are typically used to find sparse models with good predictive performance. In contrast, the stability selection proposed by \citet{MeinshausenBuehlmann2010} aims to find stable features which show strong association with the outcome. 
The stability selection is a general approach that combines feature selection methods such as $L_1$ penalized models with resampling. By applying the corresponding feature selection method to subsamples that were drawn without replacement, selection probabilities for each feature can be estimated. These selection probabilities are used to define a set of stable features. \citet{MeinshausenBuehlmann2010} provide a theoretical framework for controlling Type I error rates of falsely assigning features to the estimated set of stable features. The selection probability of each feature along the regularization path, e.g. along the range of possible penalization parameters $\Lambda=\{\lambda_1,\lambda_2...,\lambda_K\}$, is called stability path.
Given an arbitrary threshold $\pi_{thr} \in (0.5,1)$ and the set of penalization parameters $\Lambda$, the set of stable features estimated with the stability selection is:
\begin{equation} 
 \hat{S}_{\beta}^{stable}=\left\{j: \max_{\lambda_{k} \in \Lambda} \hat{\Pi}_{j}^{\lambda_{k}} \geq \pi_{thr} \right\},
\end{equation}
where $\hat{\Pi}_{j}^{\lambda_{k}}$ denotes the estimated selection probability of the $j$th feature at the $k$th $\lambda$. 
Then according to Theorem 1 in \citet{MeinshausenBuehlmann2010}, the expected number of falsely selected features $E(V)$ will be bounded by:
\begin{equation}\label{stab}
E(V) \leq \frac{1}{(2\pi_{thr}-1)} \frac{q^{2}_{\Lambda}}{p},
\end{equation}
where $q_{\Lambda}$ is the average of the number of non-zero coefficients w.r.t. to the drawn subsamples.  
Interpreting Equation \ref{stab} the expected number of falsely selected features decreases by either reducing the average number of selected features $q_{\Lambda}$ or by increasing the threshold $\pi_{thr}$. Suppose that $\pi_{thr}$ is fixed, then the stability selection controls $E(V)$ as long as the average number of selected features is less than $e_{\Lambda}$. 
This is an upper bound 
\begin{equation}
e_{\Lambda} = \sqrt{E(V)p(2\pi_{thr}-1)},
\end{equation}
which can be controlled by reducing the length of the regularization path $\Lambda$. In multiple testing the expected number of falsely selected features is also known as the per-family error rate (PFER) and if divided by the total number of features $p$ will become the per-comparison error rate (PCER) \citep{Dudoit2003}. The stability selection allows to control these Type I error rates. For instance, suppose the threshold $\pi_{thr} = 0.8$ is fixed, then
choosing $\Lambda$ such that $q_{\Lambda} \leq \sqrt{0.6p}$ will control $E(V)\leq 1$. Moreover, by choosing $\Lambda$ so that $q_{\Lambda} \leq \sqrt{0.6p\alpha}$ will control the family wise error rate (FWER) at level $\alpha$, $P(|V|>0) \leq \alpha$.

As mentioned before, according to \citet{FHT2010} the coordinate descent algorithm implemented in the \texttt{glmnet} is most efficient regarding the computational time, when used to calculate a whole regularization path. To utilize this property our algorithm calculates the stability path by first generating subsets and then calculating for each subset the regularization path using the coordinate descent algorithm. The resulting regularization paths are then merged to form the stability path. Furthermore, since the calculations of the regularization paths for each subset are independent of each other, the algorithm can easily be parallelized using the package \texttt{parallel}. %In parallel computing such easily to parallelize  embarrassingly parallel computations.    

\subsection{Prediction error curves for survival models}

The time-dependent Brier Score \citep{graf99} can be used to assess and compare the prediction accuracy of prognostic models.
The Brier Score at time point $t$ is a weighted mean squared error between predicted survival probability and observed survival status.
Weighting depends on the estimated censoring distribution to account for the observations under risk or more general estimates
thereof \citep{gerds2006}. Computing the error for each time point over the entire follow-up horizon yields a predicton error curve.
Prediction errors based on the Kaplan-Meier estimates ignoring any additional covariate information function as reference. 

The empirical time-dependent Brier score $BS(t)$ is defined as a function of time $t > 0$ by
\[
BS(t) = \frac{1}{n}\sum_{i=1}^{n}{\left[\frac{\hat{S}(t|x_i)^2I(t_i\leq t \wedge \delta_i=1)}{\hat{G}(t_i)} + \frac{(1-\hat{S}(t|x_i))^2I(t_i>t)}{\hat{G}(t)}\right]},
\]
with individual survival time $t_i$, censoring indicator $\delta_i$ and estimated survival probability $\hat{S}(t|x_i)$ at time $t$ based on the prognostic model given covariate values $x_i$ for subject $i$ out of $n$ patients \cite{graf99}.
$\hat G(t)$ denotes the Kaplan-Meier estimate of the censoring distribution which is based on the observations $(t_i; 1-\delta_i$), 
$I$ stands for the indicator function. 

In case no independent validation data are available, resampling-based prediction error curves are used to adequately assess the accuracy.
The $.632+$ bootstrap estimator \citep{efron1997}, which is a weighted sum of the apparent error and the average out-of-bag bootstrap error, can be used in this context, balancing a too optimistic and a too conservative error estimation. The $.632+$ bootstrap estimator is calculated based on subsampling (with replacement) rather than classical sampling wihout replacement, as that has been demonstrated to lead to more accurate estimates \citep{BS2008}.

<<setup, echo=F, results=hide>>=
rm(list=ls())

# load libraries
library(cacheSweave)
library(Biobase)
library(genefilter)
library(ggplot2)
library(GEOquery)
library(limma)
library(xtable)
library(survival)

library(glmnet)
require(penalizedSVM)
library(parallel) #for stabilityselection.R
library(peperr) #for peperr_glmnet.R
library(tgp) #for EPSGO.R
library(mlegp) #for EPSGO.R
library(pamr) #for tune.glmnet.interval.R
library(lattice) # for plotting 

library(c060)

dir.create("figures",showWarnings = FALSE)

# set cache folder; needs different driver, to run as:
# Sweave("c060_vignette.Rnw",driver=cacheSweaveDriver)
setCacheDir("cache")
@

<<GEOdataGSE12417, echo=F, results=hide>>=
if (file.exists("Rdata/expressionSet.Rdata")) {
    load("Rdata/expressionSet.Rdata") 
} else {
    library(GEOquery)
    
    dir.create("GEOdata",showWarnings = FALSE)
    dir.create("Rdata",showWarnings = FALSE)
    
    # download processed data files from url or if available get data from locally saved copies
    geo_exprs_data  <- getGEO("GSE12417", destdir="GEOdata",AnnotGPL=T)[[1]]
    annotation(geo_exprs_data) <- "hgu133plus2"
    
    #clinical characteristics including survival data are in "characteristics_ch1" in the phenoData 
    clin.df <- as.data.frame(strsplit2(as.character(pData(geo_exprs_data)$characteristics_ch1), split=";"))
    clin.df[,1] <- strsplit2(clin.df[,1]," ")[,7]
    clin.df[,2] <- as.numeric(sub("=", "", strsplit2(clin.df[,2]," ")[,3]))
    clin.df[,3] <- as.numeric(strsplit2(clin.df[,3]," ")[,4])
    clin.df[,4] <- as.numeric(strsplit2(clin.df[,4]," ")[,4])
    colnames(clin.df) <- c("FAB", "age", "os", "os_status")
    rownames(clin.df) <- rownames(pData(geo_exprs_data))
    pData(geo_exprs_data) <- clin.df

    save(geo_exprs_data, file="Rdata/expressionSet.Rdata")  
    unlink("GEOdata", recursive=TRUE) #delete GEOdata
} 
@

<<preprocessData, echo=F, results=hide>>=
# unspecific filtering: select most varying probe sets
nfeatures <- 10000
rowvars    <- rowVars(exprs(geo_exprs_data))
topprobes   <- which(rowvars>=sort(rowvars,decreasing=T)[nfeatures])
eset       <- geo_exprs_data[topprobes,]     
@

\clearpage
\section{Application and demonstration of software}
In the following we will demonstrate the use of the functions provided with the \texttt{c060} package in an application to the AML data set by \citet{metzeler08}. For the sake of convenience we reduce the total number of \Sexpr{nrow(geo_exprs_data)} gene expression features that have been measured with the Affymetrix HG-U133 Plus 2.0 microarray technology to the top \Sexpr{nfeatures} features with largest variance across all \Sexpr{ncol(eset)} samples. For all computations the data set is stored as an \texttt{ExpressionSet} (from Bioconductor package \texttt{Biobase}) called \texttt{eset}. Gene expression data can be accessed through the call \texttt{exprs(eset)} and overall survival data and other patient-specific data (e.g. patient age) are stored within the \texttt{phenoData} object \texttt{pData(eset)}.

\subsection{Starting off: Fitting the lasso-penalized Cox model} 
Our goal is to develop a prognostic model for patient overall survival based on the gene expression data. The purpose of this modelling exercise is not just to fit a prognostic model that is capable of predicting overall survival rates, but we also want to find out which gene expression features are most relevant for this task. Traditionally, this problem is solved by feature selection methods and we start our data analysis exercise by fitting the lasso-penalized Cox model, which provides automatic feature selection.

\begin{figure}
\begin{center}
<<glmnet, echo=F, results=hide, fig=TRUE, height=4>>=
set.seed(1234)
cvres <- cv.glmnet(y=Surv(pData(eset)$os, pData(eset)$os_status), x=t(exprs(eset)), family="cox", nfolds=10)
res <- cvres$glmnet.fit
plot(cvres)

cof <- coef(res, s=cvres$lambda.min)
names.cof <- rownames(cof)
cofn <- cof[which(cof!=0)]
names(cofn) <- names.cof[which(cof!=0)]
@
\end{center}
\caption{\label{fig:cvlasso}Cross-validated partial log-likelihood deviance, including upper and lower standard deviations, as a function of $\log{\lambda}$ for the AML data set. The dotted vertical lines indicate the $\lambda$ values with minimal deviance (left) and with the largest $\lambda$ value within one standard deviation of the minimal deviance (right).}
\end{figure}

We can apply the \texttt{glmnet} function to fit a lasso-penalized Cox model to the AML data set. The function call with default penalty parameter settings will fit the lasso model for 100 $\lambda$ values with a data-derived range of values:
<<glmnet0, echo=TRUE, results=hide>>=
fit <- glmnet(y=Surv(pData(eset)$os, pData(eset)$os_status), 
              x=t(exprs(eset)), family="cox")
@
 
In order to determine the optimal lasso penalty parameter value, we perform 10-fold cross-validation using the \texttt{cv.glmnet} function. The loss function, i.e. the cross-validated partial log-likelihood deviance, is shown in Figure \ref{fig:cvlasso} including upper and lower standard deviations as a function of $\log{\lambda}$ for the AML data set. The penalty parameter value minimizing the loss function is $\lambda =$\Sexpr{round(cvres$lambda.min, 3)} ($\log\lambda =$\Sexpr{round(log(cvres$lambda.min), 3)}) and corresponds to a final lasso model with the following \Sexpr{length(cofn)} selected features:
<<glmnet2, echo=F, results=verbatim>>=
print(cofn)
cofn.lasso <- cofn
#cofn.ix <- predict(res, type="nonzero", s=cvres$lambda.min)
@

The selected features are highlighted as red lines in the coefficient paths shown in Figure \ref{fig:coefpath} illustrating the development of the regression coefficient estimates with increasing regularization. While the selected \Sexpr{length(cofn)} features are the only features selected at the optimal $\lambda$ value, they do not remain among the features with largest effect sizes when the penalty is reduced and thus more and more coefficients start to enter the model. In fact, for 4 out of the \Sexpr{length(cofn)} features the coefficient estimates go back down to zero for small values of $\log\lambda$, indicating that these features get replaced by other gene expression features in very large models.

\begin{figure}
\begin{center}
<<glmnet3, echo=F, results=hide, fig=TRUE, height=7, width=7>>=
bet <- res$beta[match(names(cofn), rownames(res$beta)),]
par(mar=c(4,4,2.5,1), mgp=c(2.5,1,0), mfrow=c(2,2))

plot(res, xvar="lambda", col="gray")
glmnet:::plotCoef(bet, lambda = res$lambda, df = res$df, dev = res$dev.ratio, xvar = "lambda", add=TRUE, col="red")
abline(v=log(cvres$lambda.min), lty=3)
abline(v=log(cvres$lambda.1se), lty=3)

glmnet:::plotCoef(bet, lambda = res$lambda, df = res$df, dev = res$dev.ratio, xvar = "lambda", add=FALSE, col="red")
abline(v=log(cvres$lambda.min), lty=3)
abline(v=log(cvres$lambda.1se), lty=3)

norm <- apply(abs(res$beta), 2, sum)
plot(res, xvar="norm", col="gray")
glmnet:::plotCoef(bet, xvar = "norm", add=TRUE, col="red",
                  norm = norm, lambda = res$lambda, df = res$df, dev = res$dev.ratio)
abline(v=norm[match(cvres$lambda.min, cvres$lambda)], lty=3)
abline(v=norm[match(cvres$lambda.1se, cvres$lambda)], lty=3)

plot(res, xvar="dev", col="gray")
glmnet:::plotCoef(bet, lambda = res$lambda, df = res$df, dev = res$dev.ratio, xvar = "dev", add=TRUE, col="red")
abline(v=res$dev.ratio[match(cvres$lambda.min, cvres$lambda)], lty=3)
abline(v=res$dev.ratio[match(cvres$lambda.1se, cvres$lambda)], lty=3)
@
\end{center}
\caption{\label{fig:coefpath}Coefficient paths for lasso-penalized Cox PH regression models applied to the AML data set. The features with highlighted paths have non-zero coefficients in the model with the optimal $\lambda$ value as determined by ten-fold cross-validation. The dotted vertical have the same meaning as in Figure \ref{fig:cvlasso}. The top plots show the coefficient path scaled to reflect $\log(\lambda)$ on the x-axis (top left: full path, top right: zoomed in to only show the selected features). The bottom plots show the coefficient paths relative to the $L_1$-norms of the estimated coefficient vector (left) and to the fraction of the null partial log-likelihood deviance explained (right).}
\end{figure}

\subsection{Assessment of prediction performance with resampling-based prediction errors}
\label{pec}

Once the final prognostic model is selected, we need to assess its prediction accuracy for future patients, frequently also in comparison
with established clinico-pathological prognostic markers. In many applications no independent validation data set is available, thus the same data set needs to be used to both develop and assess the prognostic model. This is even more problematic for high-dimensional data,
where the risk of overfitting is much more present. Resampling-based methods can be used to unbiasedly estimate the predictive accuracy 
of the prognostic model in this situation. This is also called internal validation.

The \texttt{R} package \texttt{peperr} \citep{Porz2009} provides a modular framework for survival and binary endpoints, i.e. prognostic and
classification models. Wrapper functions for new or customized prediction model algorithms can be defined and passed to the generic call function \texttt{peperr}.  
In case of prognostic models, algorithm-specific wrapper functions are required for model fitting, tuning and prediction. Wrapper functions for selected machine learning approaches are already implemented, but unfortunately not yet for the \texttt{glmnet} package.

With the \texttt{peperr} package prediction accuracy of survival models is by default assessed with prediction error curves based on the time-dependent Brier score, but it is also possible to define and use customized accuracy measures.

We have implemented additional wrapper functions for the \texttt{glmnet} algorithm for fitting (\texttt{fit.glmnet}) and tuning (\texttt{complexity.glmnet}) the model,
and predicting survival probabilities (\texttt{predictProb.glmnet}) based on the fitted model and the estimated baseline hazard from the training data. 

We here want to assess the prognostic value of the $L_1$-penalized Cox PH regression model fitted in the previous section. The $.632+$ subsampling-based bootstrap estimator is calculated using 100 bootstrap samples for illustration purposes (usually one would choose larger numbers of bootstrap samples, e.g. 500 or 1000).

The \texttt{peperr} package is designed for high-dimensional covariates data and allows for various set-ups of parallel computations.
Also, additional arguments can be passed directly to the \texttt{glmnet} call by specifing additional arguments for the fitting and/or tuning procedure.
Here, we include patient's age as mandatory model feature into the prognostic model, i.e. age is not subject to penalization, and 
run the calculation on 3 CPUs in parallel using a socket cluster set-up.

<<peperrMandatoryParallel, echo=T, results=hide, cache=T>>=
obj  <- peperr(response=Surv(pData(eset)$os, pData(eset)$os_status),
         x=data.frame(eset$age,t(exprs(eset))),
         fit.fun=fit.glmnet, 
         args.fit=list(standardize=F, family="cox", 
         penalty.factor=rep(0:1, times=c(1,dim(eset)[1]))),
         complexity=complexity.glmnet,
         args.complexity=list(standardize=F, nfolds=10, 
         family="cox", 
         penalty.factor=rep(0:1, times=c(1,dim(eset)[1]))),
         trace=F, RNG="fixed", seed=0815, 
         cpus=3, parallel=T, clustertype="SOCK", 
         load.list=list(packages=c("c060")),
         indices=resample.indices(n=dim(eset)[2], sample.n=100, 
         method="sub632"))
@

Individual bootstrap results can be visualized with the \texttt{plot.peperr} function from the \texttt{peperr} package showing the selected complexity parameters, 
out-of-bag prediction error curves as well as the prediction error integrated over time, and the predictive partial log-likelihood (PLL) values. In order to calculate the predictive PLL values again an algorithm specific wrapper (here \texttt{PLL.coxnet}) needs to be defined.

In addition, we provide a slightly modified version of the prediction error curves plot function from the \texttt{peperr} package which allows to display the number still at risk (\texttt{plot.peperr.curves}) as shown in Figure \ref{fig:pec}. 

\begin{figure}
\begin{center}
<<peperrPlot, echo=T, results=hide, fig=TRUE>>=
plot.peperr.curves(obj, at.risk=T)
@
\end{center}
\caption{Prediction error curves based on time-dependent Brier score for the lasso-penalized Cox PH regression model applied to the AML data set (evaluation time points reflect days). The gray lines show the prediction error curves of 100 bootstrap samples. The other lines show the prediction error curves of the null model (estimated by the Kaplan-Meier estimator without covariate information), the full apparent error estimates (i.e. the errors as estimated when applying the model to the entire training data set), and the .632+ bootstrap error estimates.}
\label{fig:pec}
\end{figure}

Note, that for classification models, the same wrapper functions for fitting and tuning the model are called.
Model performance measures for classification tasks shipped with the \texttt{peperr} package are misclassification rate and Brier score. We have extended the functionality of the Brier score (\texttt{aggregation.brier}) and misclassification rate (\texttt{aggregation.misclass}) 
calculation for the \texttt{glmnet} algorithm, and defined AUC under the ROC curve (\texttt{aggregation.auc}) as an additional performance measure.
For binary responses, the \texttt{peperr} package does not quite provide the same modular flexibility 
as for time-to-event endpoints. The predicted class probability is calculated within the performance/aggregation function by calling the algorithm-specific predict function. Whenever a new algorithm is incorporated, the aggregation function has to be modified and overwritten accordingly.

\clearpage
\subsection{Stability selection}

We use stability selection to identify features which have a relevant influence on the survival times of the patients in the AML data set and to control Type I errors to ensure that the features identified are truly associated with the survival times. To calculate the stability path for the $L_1$-penalized Cox regression we use the function \texttt{stability.path} from our \R{} package. 
The function draws subsets and calculates in parallel the stability path, e.g. the selection probabilities of each feature along the range of possible penalization parameter values. For parallelization we use the package \texttt{parallel}, which has been a base package since \R{} version 2.14.0. On Unix-like systems the parallelization is done by forking via the function \texttt{mclapply} whereas under Windows systems socket clusters are used. To estimate the stable set of features given a desired Type I error rate, the function \texttt{stability.selection} or \texttt{plot.stabpath} can be called. Function \texttt{plot.stabpath} will not just compute the stability path but also plot the coefficient path together with the stability path, with stable features highlighted in both plots.

\begin{figure}
<<stabilitySelection, echo=F, results=hide, fig=TRUE>>=
set.seed(1234)
y <- cbind(time=pData(eset)$os, status=pData(eset)$os_status)
cores <- 2
fwer <- 0.5
pi.thr <- 0.6
#calculate stability path
res <- stability.path(y=y, x=t(exprs(eset)), weakness=1, mc.cores=cores, family="cox")
par(mar=c(4,4,2,1), mgp=c(2.5,1,0))
#plot stability path and perform stability selection controlling a fwer of 0.5
sel <- plotstabpath(res, fwer=fwer, pi_thr=pi.thr, xvar="lambda", col.all="gray")
@
\caption{\label{fig:stabpath}Coefficient and stability paths for lasso penalized Cox PH regression model applied to the AML data set. The feature with highlighted path is the only stable feature found by stability selection with FWER=\Sexpr{fwer} and $\hat\Pi >$\Sexpr{pi.thr}.}
\end{figure}

Controlling a family-wise error rate (FWER) of \Sexpr{fwer} the estimated set of stable features comprises a single feature (with $\hat\Pi >$\Sexpr{pi.thr} at $\lambda =$\Sexpr{round(sel$lambda, 3)}) which is:
<<stabilitySelection2, echo=F, results=verbatim>>=
print(sel$stable)
@
Note that an FWER threshold of \Sexpr{fwer} is unusually high. For this data set the use of smaller, more conventional thresholds, e.g. 0.05 or 0.1, will result in an empty set of stable features.

\clearpage
\subsection{Fitting the elastic net penalized Cox model}
In the previous sections we have seen that the lasso-penalized Cox model does not seem to perform very well in terms of predicting overall survival for the AML data set. While the lasso model identified as the optimal model by 10-fold cross-validation is very sparse and contains only \Sexpr{length(cofn)} features, we have seen that these features are not very stable and 4 out of these features do not even remain in the set of selected features when the amount of regularization is decreased and more features start to enter the model. Also, the $.632+$-bootstrap estimated prediction error curve indicates that the prognostic value of the lasso model does not seem to be very good.

In this section we try to fit an elastic net model instead of lasso to the same data set. As outlined above, fitting an elastic net model require the simultaneous tuning of two parameters $\alpha$ and $\lambda$. For this computationally challenging task, we provide an efficient implementation in \R{} function \texttt{EPSGO} using the interval search algorithm.

<<interval_search_cox_setup, echo=F, results=hide>>=  
  x <- t(exprs(eset))
  y <- cbind(time=pData(geo_exprs_data)$os,status=pData(geo_exprs_data)$os_status)
  
  Q.func <- "tune.glmnet.interval"
  
  # bounds for alpha [0,1]
  bounds <- t(data.frame(alpha=c(0, 1)))
  colnames(bounds) <- c("lower", "upper")  
  parms.coding <- "none"
  seed <- 1234
  type.measure <- 'deviance'
    
  family <- "cox"
  nfolds <- 10
  show <- "none"
  fminlower <- -100  
  type.min <- "lambda.1se"
  verbose <- TRUE
@
The task is to find a setting of tuning parameter values $\left(\alpha,\lambda\right)$, for which the \Sexpr{nfolds}-fold cross-validated penalized (partial) log likelihood function of the model is minimal. The parameter space of tuning parameters is defined as follows:
<<interval_search_cox_pre, echo=F>>=
print(bounds)
@

The second tuning parameter $\lambda>0$ will be found for each given $\alpha$ via the computation of the entire regularization path with the \texttt{glmnet} function. The two-dimensional parameter space has the form $\left(0, 1\right) \times \mathbb{R}_+$. %The seed is \Sexpr{seed}.
For each given $\alpha$ an optimal $\lambda$ is defined as the largest value of $\lambda$ such that the loss function value is within one standard error of the minimum.

<<interval_search_cox, echo=F, results=hide, cache=TRUE>>=
  # fix folds for each model
  set.seed(seed)
  foldid <- my.balanced.folds(class.column.factor=y[,2], cross.outer=nfolds)
  #table(foldid,y[,2])

  print("start interval search")
  fit <- EPSGO(Q.func, 
             bounds=bounds, 
             parms.coding=parms.coding, 
             show=show, N=NULL,   
             seed=seed, 
             fminlower=fminlower,
             # Q.func arguments
    				 x=x, y=y, family=family, 
             #nfolds=nfolds,  
             foldid=foldid,
             type.min=type.min,
             type.measure=type.measure,
             verbose=verbose)
  names(fit) 
 

  print("chose the model with min num of FS ")      
  print("# FS: ")
  sel.models <- sapply(fit$model.list, "[", "model") [fit$Ytrain == fit$fmin ]
  sel.alpha <- fit$xmin
  sel.error <- fit$fmin  	
  		
  out <- list(model=sel.models, alpha=sel.alpha, error=sel.error) 
  save(fit, out, file="Rdata/fit_interval_search.RData") 

@
<<interval_search_cox_extract, echo=F, results=hide>>=
# 
alphas <- fit$Xtrain[,1]
lambdas <- unlist(sapply(sapply(fit$model, "[", "model"), "[", "lambda"))
deviances <- fit$Ytrain
# round problems!!!! take first from the fit 
# number of selected features in the models; dfs
tmp.models<-sapply(sapply(sapply(fit$model, "[", "model"), "[", "cvreg"), "[", "glmnet.fit")

n.features<-mapply( function(List, lam) List$df[which(List$lambda %in% lam)], tmp.models, lambdas)
             
opt.alpha <- out$alpha
opt.lambda <- out$model[[1]]$lambda

summary_int_search <- as.data.frame(cbind(alpha=alphas,lambda=lambdas,deviance=deviances,n.features=n.features))
rownames(summary_int_search) <- c(1:nrow(summary_int_search))
@

At the initial step we sample 21 points in the parameter space, Those points are randomly distributed and uniformly cover the whole interval. A Gaussian process model is trained based on these initial points. Then,iteratively, new points are added to the Gaussian process model in order to find an optimal combination of tuning parameter values. In total, \Sexpr{nrow(summary_int_search)} iterations were needed to reach the optimum. 

%<<label=tab_int_search1, echo=FALSE, results=tex>>=                             
%toPrint <- xtable(summary_int_search[1:5,], caption = "Summary of five intial points in the parameter space", label = "tab:sum_int_search1", digits = c(0,5, 7, 5, 0))
%print(toPrint, table.placement = "tbp", caption.placement = "top")
%@
%The first five initial 'visited' points in the parameter space ($\alpha$, $\lambda$)  with corresponding cross-validated deviance and number of selected features in each model are presented in Table~\ref{tab:sum_int_search1}.

%<<label=tab_int_search2, echo=FALSE, results=tex>>=                             
%toPrint <- xtable(summary_int_search[22:31,], caption = "Summary of visited points in the parameter space", label = "tab:sum_int_search2", digits = c(0,5, 7, 5, 0))
%print(toPrint, table.placement = "tbp", caption.placement = "top")
%@

%The next section of the summary table shows ten 'visited' points, which are chosen in iteration steps (Table~\ref{tab:sum_int_search2}).
%The minimal mean cross-validated deviance over the folds of \Sexpr{round(out$error,3)} was reached for optimal parameter pair $(\alpha, \lambda ) $ = (\Sexpr{round(opt.alpha,3)},\Sexpr{round(opt.lambda,3)}). 

<<interval_search_cox_fit_opt, echo=F, results=hide>>=
#select the model with optimal parameters from the object fit
# 
f <- fit$model.list[unlist(sapply(fit$model.list,"[",1)) == fit$fmin]
if (length(f)>1) print("more than one optimal model!")
#take the first model
f1 <- f[[1]]$model$cvreg
res<-f1$glmnet.fit
cof <- coef(res, s=opt.lambda)
names.cof <- rownames(cof)
cofn <- cof[which(cof!=0)]
names(cofn) <- names.cof[which(cof!=0)] 
bet <- res$beta[match(names(cofn), rownames(res$beta)),]
@

The final elastic net model contains \Sexpr{length(cofn)} selected features, which obviously reflects much less sparsity than the final lasso model.
<<interval_search_cox_summary, results=hide>>=
summary(cofn)
head(sort(cofn))
tail(sort(cofn))
@

The results are consistent in the sense, that the features contained in the final lasso model are also contained in the elastic net model. Also, the individual feature selected by the stability algorithm is in the set of selected elastic net features.
<<interval_search_cox_check_overlap_stability, results=hide>>=
names(cofn.lasso) %in% names.cof
'206932_at' %in% names.cof
@

\begin{figure}
<<interval_search_cox_out_plot1, echo=F, results=hide, fig=TRUE,height=10>>=
 
# breaks <- do.breaks(range(summary_int_search$deviance), 20)
# n_init <- 20 # number of initial alpha values at iteration zero
# summary_int_search$cols <- level.colors(summary_int_search$deviance,at=breaks, col.regions = cm.colors(n=20,alpha=0.5))
# print(xyplot(alpha ~ lambda, data = summary_int_search, groups = cols, cex = 2, col = "black",   jitter.y=T, amount=0.01,
#              scales=list(x=list(log=T, equispaced.log = FALSE)), # x axis on log-scale
#              panel = function(x, y, groups, ..., subscripts) { 
#              fill <- groups[subscripts] 
#              panel.grid(h = -1, v = -1)
#              panel.xyplot(x, y, pch = rep(c(22,21),c(n_init,nrow(summary_int_search)-n_init)), fill = fill, ...) ;
#              ltext(x=x, y=y, labels=n.features, pos=ifelse(y<0.1,3,4), offset=3, cex=0.75,col=4)},
#              legend = list(top = list(fun = draw.colorkey, args = list(key = list(space = "top", col = cm.colors(n=20,alpha=0.5), at = breaks), draw = FALSE))),
#              main="cross-validated model deviance",sub="number of selected features are given in blue \n rectangles show initial alpha values"))

summary_int_search$log_lambda <- log(summary_int_search$lambda)
breaks                        <- do.breaks(range(summary_int_search$deviance), 20)
n_init                        <- 21 # number of initial alpha values at iteration zero
summary_int_search$cols       <- level.colors(summary_int_search$deviance,at=breaks, col.regions = gray.colors)

print(xyplot(alpha ~ log_lambda, data = summary_int_search, groups = cols, cex = 2, col = "black",  
             jitter.y=T, amount=0.01, xlab=expression(paste("log ",lambda)),ylab=expression(alpha),
#             scales=list(x=list(log=T, equispaced.log = FALSE)), # x axis on log-scale
             panel = function(x, y, groups, ..., subscripts) { 
             fill <- groups[subscripts] 
             panel.grid(h = -1, v = -1)
             panel.xyplot(x, y, pch = rep(c(22,21),c(n_init,nrow(summary_int_search)-n_init)), fill = fill, ...) ;
             ltext(x=x, y=y, labels=n.features, pos=ifelse(y<0.1,3,4), offset=3, cex=1,col=1)},
             legend = list(top = list(fun = draw.colorkey, args = list(key = list(space = "top", col = gray.colors, at = breaks), draw = FALSE))),
             main="Cross-validated partial log likelihood deviance",
             #sub="number of selected features are printed next to symbol \n rectangles show initial alpha values"
             ))
@
\caption{\label{fig:interval_search1} \textbf{Top}: Partial log likelihood deviance as a function of both tuning parameters $\alpha$ and log$\lambda$ when fitting the elastic net Cox model for the AML data set. For each evaluated point in the parameter space the number of selected features in the corresponding model is printed next to the data point symbol. Rectangles correspond to initially selected $\alpha$ values.}
\end{figure}

Figure~\ref{fig:interval_search1} illustrates the relationship between both tuning parameters $\alpha$ and $\lambda$ for the 'visited' points. The partial log likelihood deviance is  color-coded with black for small values and gray for large values. 
To distinguish between initial and iteration points, the initial points are plotted as  squares and iteration points as circles. The iteration points were chosen in the regions with lower deviance values. The number of features selected  inthe corresponding model is written near each point. 

The distribution of initial points (iteration=0) and visited points (iteration>0) in the parameter space is plotted in Figure~\ref{fig:interval_search2}).
This plot shows nicely that the interval search algorithm does not sequentially cover the entire parameter space, but rather quickly finds promising regions and draws new samples in those promising regions.The optimal model is found at a small value for $\alpha$ =\Sexpr{opt.alpha} highlighted as a vertical line.

\begin{figure}
<<interval_search_cox_out_plot2, echo=F, results=hide, fig=TRUE,height=6>>=
niter<-nrow(summary_int_search) - 21
iter<-c(rep(0,21), c(1:niter))
plot(summary_int_search$alpha, iter, xlab=expression(alpha), ylab="Iteration")
grid(NA, niter+1, lwd=2)
abline(v=opt.alpha, col="red")
@
\caption{\label{fig:interval_search2} The distribution of initial and visited points of the interval search plotted in chronological order. The interval search is employed to identify the optimal parameter value combination ($\alpha$,$\lambda$) for the elastic net Cox model fitted to the AML data set.}
\end{figure}

\clearpage
\section{Conclusions and outlook}
The programming language and statistical computing environment \R{} provides a highly useful framework for statistical data analysis and modelling. It is the dominating statistical software in many areas, for example in molecular biology and molecular medicine, which is largely due to the highly successful Bioconductor project, which provides tools for the analysis and comprehension of high-throughput genomic data. Due to the open-source nature of \R{} and Bioconductor, many very useful software packages have been developed by \R{} users and made available for the entire \R{} community. One example is the \texttt{glmnet} package, which  implements an efficient state-of-the-art algorithm for fitting penalized Cox and generalized linear models \citep{FHT2010,simon2011}.

We have presented our \R{} package \texttt{c060}, which provides extensions to \texttt{glmnet} and additional features which are essential for a full data analysis in practical applications, including stability selection, estimation of prediction error (curves) and an efficient interval search algorithm for finding the optimal elastic net tuning parameter combination. These extensions have proved useful in our daily work, in particular for the task of performing prognostic modelling of patient survival data based on high-dimensional molecular biology data.

The \texttt{c060} package will be kept updated in the future to keep up with the fast-developing field of penalized regression methodology for feature selection and risk prediction modelling with high-dimensional input data. One example are developments for the estimation of standard errors, confidence intervals and the determination of p-values in high-dimensional regularized regression models, e.g. through subsampling methods similar to the approach taken by \citet{wasserman2009} and \citet{MeinshausenBuehlmann2010}.

%\section{Session Information}
%The version number of \R{} and packages loaded for generating the vignette were:
%<<sessionInfo, echo=FALSE, results=tex>>=
%toLatex(sessionInfo())
%@

\clearpage
\bibliographystyle{model2-names}
\bibliography{c060}   % name your BibTeX data base

\end{document}