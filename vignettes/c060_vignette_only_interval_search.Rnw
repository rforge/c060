% setwd("C:/Projekte/explained variation/peperr/CSDA/c060/pkg/vignettes")
% setwd("~/Projekte_StatsMethods/c060/pkg/vignette")
% library(cacheSweave)
% Sweave("c060_vignette.Rnw", driver = cacheSweaveDriver)
% tools::texi2dvi("c060_vignette.tex", pdf=TRUE)

\documentclass[a4paper, 11pt]{article}

\parskip 0.5em  
\parindent 0em

\oddsidemargin-5mm
\evensidemargin-5mm
\textwidth165mm

%\smartqed  % flush right qed marks, e.g. at end of proof

\usepackage{graphicx}
\usepackage{mathptmx}      % use Times fonts if available on your TeX system
\usepackage[authoryear]{natbib}
\usepackage{longtable}
\usepackage{hyperref}

% please place your own definitions here and don't use \def but
% \newcommand{}{}
\newcommand{\Scmd}[1]{\texttt{#1}} % For R/ S commands
\newcommand{\R}{R}

\begin{document}
\SweaveOpts{concordance=TRUE}

\setkeys{Gin}{width=\textwidth}% general figure width
\SweaveOpts{prefix.string=figures/fig, eps=FALSE}
%Because eps=FALSE, all graphics are created as pdf graphics only. This implies that the resulting tex document needs to be compiled with pdflatex rather than with latex.

\title{C060 Vignette}%
\author{Martin Sill, Thomas Hielscher, Natalia Becker, Manuela Zucknick}
\date{}

\maketitle

\section{Introduction}

Data from published gene expression studies are often deposited in public data repositories, for example on the Gene Expression Omnibus (GEO) website by the NCBI (National Center for Biotechnology Information): \url{http://www.ncbi.nlm.nih.gov/geo}. We find the Metzeler \textit{et al.} data under GEO accession number GSE12417.

Here should follow a detailed description of 
\begin{enumerate}
\item the problem (what do we want to do)
\item the existing methods and R software (what exists in glmnet package and which functions are missing)
\item the data set
\end{enumerate}

<<setup, echo=F, results=hide>>=
rm(list=ls())

#################################################
### load libraries
#################################################
library(cacheSweave)
library(Biobase)
library(genefilter)
library(glmnet)
library(parallel)
library(peperr)
library(ggplot2)
library(GEOquery)
library(limma)


#########################################
# R functions required
#########################################
source("../R/peperr_glmnet.r")
source("../R/stabilityselection.R")

#################################################
### set folder for automatically created figures
### to be specified in \SweaveOpts
#################################################
dir.create("figures",showWarnings = FALSE)

#########################################
# set cache folder
# needs different driver, to run as:
# Sweave("c060_vignette.Rnw",driver=cacheSweaveDriver)
#########################################
setCacheDir("cache")
@

<<GEOdataGSE12417, echo=F, results=hide>>=
if (file.exists("Rdata/expressionSet.Rdata")) {
    load("Rdata/expressionSet.Rdata") 
} else {
    library(GEOquery)
    
    dir.create("GEOdata",showWarnings = FALSE)
    dir.create("Rdata",showWarnings = FALSE)
    
    # download processed data files from url or if available get data from locally saved copies
    geo_exprs_data  <- getGEO("GSE12417", destdir="GEOdata",AnnotGPL=T)[[1]]
    annotation(geo_exprs_data) <- "hgu133plus2"
    
    #clinical characteristics including survival data are in "characteristics_ch1" in the phenoData 
    clin.df <- as.data.frame(strsplit2(as.character(pData(geo_exprs_data)$characteristics_ch1), split=";"))
    clin.df[,1] <- strsplit2(clin.df[,1]," ")[,7]
    clin.df[,2] <- as.numeric(sub("=", "", strsplit2(clin.df[,2]," ")[,3]))
    clin.df[,3] <- as.numeric(strsplit2(clin.df[,3]," ")[,4])
    clin.df[,4] <- as.numeric(strsplit2(clin.df[,4]," ")[,4])
    colnames(clin.df) <- c("FAB", "age", "os", "os_status")
    rownames(clin.df) <- rownames(pData(geo_exprs_data))
    pData(geo_exprs_data) <- clin.df

    save(geo_exprs_data, file="Rdata/expressionSet.Rdata")  
    unlink("GEOdata", recursive=TRUE) #delete GEOdata
} 
@

<<preprocessData, echo=F, results=hide>>=
##########################################
### unspecific filtering
#   select most varying probe sets
##########################################
rowvars    <- rowVars(exprs(geo_exprs_data))
topprobes   <- which(rowvars>=sort(rowvars,decreasing=T)[10000])
eset       <- geo_exprs_data[topprobes,]     
@


% \clearpage
% \section{Cox model: Inconsistence of cv.glmnet?}
% 
% By running interval search I've observed that cv.glmnet and glmnet provide different models.
% 
% <<>>=
%   source("../R/tune_glmnet_interval.R")
% 
% alpha<-0.03556
% seed<-1234
% type.measure='deviance'
% nfolds=10
% family="cox"
% grouped=T
%  type.min="lambda.1se"
% 
% 
%  x<-t(exprs(eset))
%   y=cbind(time=pData(geo_exprs_data)$os,status=pData(geo_exprs_data)$os_status)
%  
%   set.seed(seed)
%   foldid<-my.balanced.folds (class.column.factor=y[,2], cross.outer=nfolds)
% 
% 
%  set.seed(seed)
%   cv<-cv.glmnet(x=x,y=y,family=family,  
%                 alpha=alpha,
%                 offset = NULL,
%                 lambda = NULL, 
%                 type.measure =type.measure,
%                 nfolds = nfolds, 
%                 foldid = foldid,
%                 grouped = grouped)
%   
%  
%   opt.lambda<-ifelse(type.min=="lambda.min", cv$lambda.min, cv$lambda.1se )
%   
%   # q.val= mean cross-validated error over the folds
%   q.val<-cv$cvm[which(cv$lambda == opt.lambda) ]
%   
% 
%    
%   #  3. fit  the model for given alpha and opt.lambda ########################################################
%   # fit the model for given alpha and opt.lambda
%   fit<-glmnet(x=x,y=y,family=family,
%               alpha=alpha, 
%               lambda=opt.lambda)
%   
% str(fit)
% print(fit)
% str(cv$glmnet.fit)
% 
% cvres <- cv$glmnet.fit
% print(cv$glmnet.fit)
% 
% cvcof <- coef(cvres, s=opt.lambda)
% names.cvcof <- rownames(cvcof)
% cvcofn <- cvcof[which(cvcof!=0)]
% names(cvcofn) <- names.cvcof[which(cvcof!=0)]
% 
% str(cvcofn)
% 
% res <- fit
% cof <- coef(res, s=opt.lambda)
% names.cof <- rownames(cof)
% cofn <- cof[which(cof!=0)]
% names(cofn) <- names.cof[which(cof!=0)]
% 
% str(cofn)
% 
% intersect(names(cvcofn),names(cofn))
% setdiff(names(cvcofn),names(cofn))
% setdiff(names(cofn),names(cvcofn))
% 
% @


\clearpage
\section{Cox model: Tune both $\lambda$ and $\alpha$ by the interval search}

<<interval_search_cox_setup, echo=F, results=hide>>=
require(glmnet)
require(penalizedSVM)
  source("../R/EPSGO.R")
  source("../R/tune_glmnet_interval.R")
  
  x<-t(exprs(eset))
  y=cbind(time=pData(geo_exprs_data)$os,status=pData(geo_exprs_data)$os_status)
  
  Q.func<- "tune.glmnet.interval"
    
  
  # bounds for alpha [0,1]
  bounds=t(data.frame(alpha=c(0, 1)))
  colnames(bounds)<-c("lower", "upper")  
  parms.coding="none"
  seed <- 1234
  type.measure='deviance'
    
  family="cox"
  nfolds=10
  show="none"
  fminlower<- -100	
  type.min="lambda.1se"
  verbose=T


@

The task is to find such a setting of tuning parameters $\left(\alpha,\lambda\right)$, for which the \Sexpr{nfolds}-fold cross validation error of the model is minimal.
Instead of using a fixed grid, an interval search approach is applied. REFF 

The parameter space of tuning parameters is defined as follows:

<<interval_search_cox_pre, echo=F>>=
print(bounds)
@
The second tuning parameter $\lambda$ will be found for each given $\alpha$ via regularization path.  Thus, the two dimensional parameter space has the form $\left(0, 1\right) \times \mathbb{R}$. The seed is \Sexpr{seed}. For each given $\alpha$ an optimal lambda is definded as largest value of lambda such that error is within 1 standard error of the minimum. (parameter  type.min = 'lambda.1se').


<<interval_search_cox, echo=F, results=hide>>=
if (file.exists("Rdata/fit_interval_search.RData")) {
    load("Rdata/fit_interval_search.RData") 
} else {
   
  # same folds for each alpha? yes
  # fix folds for each model
  set.seed(seed)
  foldid<-my.balanced.folds (class.column.factor=y[,2], cross.outer=nfolds)
 
  
  print("start interval search")
  fit<-EPSGO(Q.func, 
             bounds=bounds, 
             parms.coding=parms.coding, 
             show=show, N=NULL,   
             seed=seed, 
             fminlower=fminlower,
             # Q.func arguments
  					 x=x, y=y, family=family, 
             #nfolds=nfolds,  
             foldid=foldid,
             type.min=type.min,
             type.measure=type.measure,
             verbose=verbose)
  
  names(fit) 
  # [1] "fmin"        "xmin"        "iter"        "neval"       "maxevals"    "seed"       
  # [7] "bounds"      "Q.func"      "points.fmin" "Xtrain"      "Ytrain"      "gp.seed"    
  #[13] "model.list"
  #plot(cbind(fit$Xtrain[,1],fit$Ytrain), ylab=type.measure, xlab="alpha", type="p")
 
  print("chose the model with min num of FS ")
      
  		print("# FS: ")
  		sel.models<-  sapply(fit$model.list, "[", "model") [fit$Ytrain == fit$fmin ]
  		sel.alpha=fit$xmin
      sel.error= fit$fmin
  		
  		
  out<-list(model=sel.models,
            alpha=sel.alpha,
            error=sel.error) 
  save(fit,out,file="Rdata/fit_interval_search.RData")
 
  
}

@

<<interval_search_cox_extract, echo=F, results=hide>>=
# 
alphas<-fit$Xtrain[,1]
lambdas<- unlist(sapply(sapply(fit$model, "[", 2), "[", 5))
diviances<-  fit$Ytrain
# number of selected features in the models; dfs
n.features<-unlist(sapply(sapply(fit$model, "[", 2), "[", 3))

opt.alpha = out$alpha
opt.lambda = out$model[[1]]$lambda

summary_int_search<-as.data.frame(cbind(alpha=alphas,lambda=lambdas,diviance=diviances,n.features=n.features))
rownames(summary_int_search) <-c(1:nrow(summary_int_search))
@

<<label=tab_int_search,echo=FALSE,results=tex>>=
 library(xtable)                              
 toPrint<-xtable(summary_int_search, caption =  "Summary of visited points in the parameter space", label = "tab:sum_int_search",
                 digits = c(0,5, 7, 5, 0))
 print(toPrint, table.placement = "tbp", caption.placement = "top")
@
Extracting tuning parameters $\alpha$, $\lambda$ and diviances as cross validation errors are presented in table~\ref{tab:sum_int_search}.

The minimal mean cross-validated error over the folds (diviance) of  \Sexpr{out$error} is reached for 
 optimal parameter pair $(\alpha, \lambda ) $ = (\Sexpr{opt.alpha},\Sexpr{opt.lambda}). 

The 'visited' points with corresponding diviance and number of selected features in each model are presented in figure~\ref{tab:sum_int_search}. 

<<interval_search_cox_fit_opt, echo=F, results=hide>>=
#select the model with optimal parameters from the object fit
# 
f<-fit$model.list[unlist(sapply(fit$model.list,"[",1)) == fit$fmin]

if (length(f)>1) print("more than one optimal model!")
#take the first model
f1<-f[[1]]$model



# fit the model with found optimal alpha
set.seed(seed)
cvres <- cv.glmnet(y=y, x=t(exprs(eset)), family="cox", nfolds=10, alpha=opt.alpha)
res <- cvres$glmnet.fit


cof <- coef(res, s=opt.lambda)
names.cof <- rownames(cof)
cofn <- cof[which(cof!=0)]
names(cofn) <- names.cof[which(cof!=0)]


                      
@

<<>>=
summary(cofn)
head(sort(cofn))
tail(sort(cofn))
@

A feature selected by the stability algorithm is in the set of selected features
<<>>=
'206932_at' %in% names.cof
@


\textbf{TODO : plots}

\begin{figure}
<<interval_search_cox_out_plot, echo=F, results=hide, fig=TRUE, height=4>>=
plot(cvres)
@
\caption{\label{fig:interval_search} \Sexpr{type.measure} as a function of log($\alpha$) for the AML data set. }
\end{figure}

% 
% 
% \begin{figure}
% <<interval_search_cox_out_plot2, echo=F, results=hide, fig=TRUE, height=4>>=
% 
% par(las=3)
% plot(cbind(alphas,diviances), ylab="Partial Likelihood Deviance", xlab="alpha", type="p")
% axis(3,at=alphas, tick = TRUE, labels=n.features,cex.axis=0.7 )
% 
% abline(v=out$alpha, col="red")
% 
% 
% 
% plot(cbind(alphas,lambdas),  xlab="alpha", ylab="lambda", type="p")
% 
% @
% \caption{\label{fig:interval_search2} \Sexpr{type.measure} as a function of $\alpha$ for the AML data set. err ewr 22222}
% \end{figure}
% 
% 
% 
% 


\clearpage
\section{Summary}

\section{Session Information}
The version number of \R{} and packages loaded for generating the vignette were:
<<sessionInfo, echo=FALSE, results=tex>>=
toLatex(sessionInfo())
@

\clearpage
%\bibliographystyle{spbasic}      % basic style, author-year citations 
%\bibliography{c060}   % name your BibTeX data base

\end{document}